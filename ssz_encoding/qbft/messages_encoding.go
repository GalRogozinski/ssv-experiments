// Code generated by fastssz. DO NOT EDIT.
// Hash: 953c1cb2f0d144592c5b1640319ffcefae56e5cf6acc962bcc3821cd12fca1b7
package qbft

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the CommitMessage object
func (c *CommitMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitMessage object to a target array
func (c *CommitMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Height'
	dst = ssz.MarshalUint64(dst, c.Height)

	// Field (1) 'Round'
	dst = ssz.MarshalUint64(dst, c.Round)

	// Field (2) 'Digest'
	dst = append(dst, c.Digest[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the CommitMessage object
func (c *CommitMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 48 {
		return ssz.ErrSize
	}

	// Field (0) 'Height'
	c.Height = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Round'
	c.Round = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Digest'
	copy(c.Digest[:], buf[16:48])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitMessage object
func (c *CommitMessage) SizeSSZ() (size int) {
	size = 48
	return
}

// HashTreeRoot ssz hashes the CommitMessage object
func (c *CommitMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitMessage object with a hasher
func (c *CommitMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Height'
	hh.PutUint64(c.Height)

	// Field (1) 'Round'
	hh.PutUint64(c.Round)

	// Field (2) 'Digest'
	hh.PutBytes(c.Digest[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitMessage object
func (c *CommitMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the SignedCommitMessage object
func (s *SignedCommitMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedCommitMessage object to a target array
func (s *SignedCommitMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(148)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(CommitMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedCommitMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedCommitMessage object
func (s *SignedCommitMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 148 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(CommitMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:48]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[48:52]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 148 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[52:148])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedCommitMessage object
func (s *SignedCommitMessage) SizeSSZ() (size int) {
	size = 148

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedCommitMessage object
func (s *SignedCommitMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedCommitMessage object with a hasher
func (s *SignedCommitMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedCommitMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedCommitMessage object
func (s *SignedCommitMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the PrepareMessage object
func (p *PrepareMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PrepareMessage object to a target array
func (p *PrepareMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Height'
	dst = ssz.MarshalUint64(dst, p.Height)

	// Field (1) 'Round'
	dst = ssz.MarshalUint64(dst, p.Round)

	// Field (2) 'Digest'
	dst = append(dst, p.Digest[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the PrepareMessage object
func (p *PrepareMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 48 {
		return ssz.ErrSize
	}

	// Field (0) 'Height'
	p.Height = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Round'
	p.Round = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Digest'
	copy(p.Digest[:], buf[16:48])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PrepareMessage object
func (p *PrepareMessage) SizeSSZ() (size int) {
	size = 48
	return
}

// HashTreeRoot ssz hashes the PrepareMessage object
func (p *PrepareMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PrepareMessage object with a hasher
func (p *PrepareMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Height'
	hh.PutUint64(p.Height)

	// Field (1) 'Round'
	hh.PutUint64(p.Round)

	// Field (2) 'Digest'
	hh.PutBytes(p.Digest[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PrepareMessage object
func (p *PrepareMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the SignedPrepareMessage object
func (s *SignedPrepareMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedPrepareMessage object to a target array
func (s *SignedPrepareMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(148)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(PrepareMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedPrepareMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedPrepareMessage object
func (s *SignedPrepareMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 148 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(PrepareMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:48]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[48:52]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 148 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[52:148])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedPrepareMessage object
func (s *SignedPrepareMessage) SizeSSZ() (size int) {
	size = 148

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedPrepareMessage object
func (s *SignedPrepareMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedPrepareMessage object with a hasher
func (s *SignedPrepareMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedPrepareMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedPrepareMessage object
func (s *SignedPrepareMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the ProposalMessage object
func (p *ProposalMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposalMessage object to a target array
func (p *ProposalMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Height'
	dst = ssz.MarshalUint64(dst, p.Height)

	// Field (1) 'Round'
	dst = ssz.MarshalUint64(dst, p.Round)

	// Field (2) 'Digest'
	dst = append(dst, p.Digest[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the ProposalMessage object
func (p *ProposalMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 48 {
		return ssz.ErrSize
	}

	// Field (0) 'Height'
	p.Height = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Round'
	p.Round = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Digest'
	copy(p.Digest[:], buf[16:48])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposalMessage object
func (p *ProposalMessage) SizeSSZ() (size int) {
	size = 48
	return
}

// HashTreeRoot ssz hashes the ProposalMessage object
func (p *ProposalMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProposalMessage object with a hasher
func (p *ProposalMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Height'
	hh.PutUint64(p.Height)

	// Field (1) 'Round'
	hh.PutUint64(p.Round)

	// Field (2) 'Digest'
	hh.PutBytes(p.Digest[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ProposalMessage object
func (p *ProposalMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the SignedProposalMessage object
func (s *SignedProposalMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedProposalMessage object to a target array
func (s *SignedProposalMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(148)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(ProposalMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedProposalMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedProposalMessage object
func (s *SignedProposalMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 148 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(ProposalMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:48]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[48:52]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 148 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[52:148])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedProposalMessage object
func (s *SignedProposalMessage) SizeSSZ() (size int) {
	size = 148

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedProposalMessage object
func (s *SignedProposalMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedProposalMessage object with a hasher
func (s *SignedProposalMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedProposalMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedProposalMessage object
func (s *SignedProposalMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the RoundChangeMessage object
func (r *RoundChangeMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundChangeMessage object to a target array
func (r *RoundChangeMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Height'
	dst = ssz.MarshalUint64(dst, r.Height)

	// Field (1) 'Round'
	dst = ssz.MarshalUint64(dst, r.Round)

	// Field (2) 'PreparedValue'
	dst = append(dst, r.PreparedValue[:]...)

	// Field (3) 'PreparedRound'
	dst = ssz.MarshalUint64(dst, r.PreparedRound)

	return
}

// UnmarshalSSZ ssz unmarshals the RoundChangeMessage object
func (r *RoundChangeMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'Height'
	r.Height = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Round'
	r.Round = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'PreparedValue'
	copy(r.PreparedValue[:], buf[16:48])

	// Field (3) 'PreparedRound'
	r.PreparedRound = ssz.UnmarshallUint64(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundChangeMessage object
func (r *RoundChangeMessage) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the RoundChangeMessage object
func (r *RoundChangeMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundChangeMessage object with a hasher
func (r *RoundChangeMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Height'
	hh.PutUint64(r.Height)

	// Field (1) 'Round'
	hh.PutUint64(r.Round)

	// Field (2) 'PreparedValue'
	hh.PutBytes(r.PreparedValue[:])

	// Field (3) 'PreparedRound'
	hh.PutUint64(r.PreparedRound)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundChangeMessage object
func (r *RoundChangeMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedRoundChangeMessage object to a target array
func (s *SignedRoundChangeMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(156)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(RoundChangeMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedRoundChangeMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 156 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(RoundChangeMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:56]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[56:60]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 156 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[60:156])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) SizeSSZ() (size int) {
	size = 156

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedRoundChangeMessage object with a hasher
func (s *SignedRoundChangeMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedRoundChangeMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
