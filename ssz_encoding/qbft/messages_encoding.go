// Code generated by fastssz. DO NOT EDIT.
// Hash: 19586ec759bf3a511405f5dc9f7deba49421a6b19e1525045071d8faa3557f31
package qbft

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the BaseMessage object
func (b *BaseMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BaseMessage object to a target array
func (b *BaseMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'ID'
	dst = append(dst, b.ID[:]...)

	// Field (1) 'Height'
	dst = ssz.MarshalUint64(dst, b.Height)

	// Field (2) 'Round'
	dst = ssz.MarshalUint64(dst, b.Round)

	// Field (3) 'Digest'
	dst = append(dst, b.Digest[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BaseMessage object
func (b *BaseMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 100 {
		return ssz.ErrSize
	}

	// Field (0) 'ID'
	copy(b.ID[:], buf[0:52])

	// Field (1) 'Height'
	b.Height = ssz.UnmarshallUint64(buf[52:60])

	// Field (2) 'Round'
	b.Round = ssz.UnmarshallUint64(buf[60:68])

	// Field (3) 'Digest'
	copy(b.Digest[:], buf[68:100])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BaseMessage object
func (b *BaseMessage) SizeSSZ() (size int) {
	size = 100
	return
}

// HashTreeRoot ssz hashes the BaseMessage object
func (b *BaseMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BaseMessage object with a hasher
func (b *BaseMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ID'
	hh.PutBytes(b.ID[:])

	// Field (1) 'Height'
	hh.PutUint64(b.Height)

	// Field (2) 'Round'
	hh.PutUint64(b.Round)

	// Field (3) 'Digest'
	hh.PutBytes(b.Digest[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BaseMessage object
func (b *BaseMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedCommitMessage object
func (s *SignedCommitMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedCommitMessage object to a target array
func (s *SignedCommitMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(200)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BaseMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedCommitMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedCommitMessage object
func (s *SignedCommitMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 200 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BaseMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:100]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[100:104]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 200 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[104:200])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedCommitMessage object
func (s *SignedCommitMessage) SizeSSZ() (size int) {
	size = 200

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedCommitMessage object
func (s *SignedCommitMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedCommitMessage object with a hasher
func (s *SignedCommitMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedCommitMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedCommitMessage object
func (s *SignedCommitMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SignedPrepareMessage object
func (s *SignedPrepareMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedPrepareMessage object to a target array
func (s *SignedPrepareMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(200)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BaseMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedPrepareMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedPrepareMessage object
func (s *SignedPrepareMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 200 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BaseMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:100]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[100:104]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 200 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[104:200])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedPrepareMessage object
func (s *SignedPrepareMessage) SizeSSZ() (size int) {
	size = 200

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedPrepareMessage object
func (s *SignedPrepareMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedPrepareMessage object with a hasher
func (s *SignedPrepareMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedPrepareMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedPrepareMessage object
func (s *SignedPrepareMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SignedProposalMessage object
func (s *SignedProposalMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedProposalMessage object to a target array
func (s *SignedProposalMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(200)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BaseMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedProposalMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedProposalMessage object
func (s *SignedProposalMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 200 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(BaseMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:100]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[100:104]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 200 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[104:200])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedProposalMessage object
func (s *SignedProposalMessage) SizeSSZ() (size int) {
	size = 200

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedProposalMessage object
func (s *SignedProposalMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedProposalMessage object with a hasher
func (s *SignedProposalMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedProposalMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedProposalMessage object
func (s *SignedProposalMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the RoundChangeMessage object
func (r *RoundChangeMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundChangeMessage object to a target array
func (r *RoundChangeMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Message'
	if r.Message == nil {
		r.Message = new(BaseMessage)
	}
	if dst, err = r.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'PreparedRound'
	dst = ssz.MarshalUint64(dst, r.PreparedRound)

	return
}

// UnmarshalSSZ ssz unmarshals the RoundChangeMessage object
func (r *RoundChangeMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 108 {
		return ssz.ErrSize
	}

	// Field (0) 'Message'
	if r.Message == nil {
		r.Message = new(BaseMessage)
	}
	if err = r.Message.UnmarshalSSZ(buf[0:100]); err != nil {
		return err
	}

	// Field (1) 'PreparedRound'
	r.PreparedRound = ssz.UnmarshallUint64(buf[100:108])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundChangeMessage object
func (r *RoundChangeMessage) SizeSSZ() (size int) {
	size = 108
	return
}

// HashTreeRoot ssz hashes the RoundChangeMessage object
func (r *RoundChangeMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundChangeMessage object with a hasher
func (r *RoundChangeMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = r.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'PreparedRound'
	hh.PutUint64(r.PreparedRound)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundChangeMessage object
func (r *RoundChangeMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedRoundChangeMessage object to a target array
func (s *SignedRoundChangeMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(208)

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(RoundChangeMessage)
	}
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signers) * 8

	// Field (2) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (1) 'Signers'
	if size := len(s.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("SignedRoundChangeMessage.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(s.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, s.Signers[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 208 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(RoundChangeMessage)
	}
	if err = s.Message.UnmarshalSSZ(buf[0:108]); err != nil {
		return err
	}

	// Offset (1) 'Signers'
	if o1 = ssz.ReadOffset(buf[108:112]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 208 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signature'
	copy(s.Signature[:], buf[112:208])

	// Field (1) 'Signers'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		s.Signers = ssz.ExtendUint64(s.Signers, num)
		for ii := 0; ii < num; ii++ {
			s.Signers[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) SizeSSZ() (size int) {
	size = 208

	// Field (1) 'Signers'
	size += len(s.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedRoundChangeMessage object with a hasher
func (s *SignedRoundChangeMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signers'
	{
		if size := len(s.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("SignedRoundChangeMessage.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedRoundChangeMessage object
func (s *SignedRoundChangeMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
